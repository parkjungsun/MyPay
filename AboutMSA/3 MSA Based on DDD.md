## 도메인 주도 설계 (DDD, Domain-Driven Design)
* 하나의 소프트웨어 개발 방법론으로, 복잡한 도메인을 이해하고 해결하는 데에 목적이 있고 집중하는 방법론.
* why? 도메인이 복잡해지면서 생기는 문제들이 아키텍처를 엉망으로 만드는 경우가 많음, 결과적으로 유지보수를 어렵게 만듬.
* 서비스 식별에 큰 도움이 된다 - Bounded Context, Sub-Domain 개념이 MSA 목적과 너무 잘 부합함.
* DDD 핵심 개념/원칙은 MSA 핵심 개념이었던 개별 팀이 Product 서비스를 소유한다는 사고방식과 일치함.

### 도메인 주도 설계 핵심 개념/원칙
* 유비쿼터스 언어(공통 언어 약속)
  * 복잡한 도메인을 해결하기 위한 팀이 공통으로 쓰기 위한 언어 약속
* 도메인 모델
  * 유비쿼터스 언어를 사용하여 요구사항을 만족시키기 위해, 도메인의 핵심 개념과 규칙을 표현하는 객체들의 관계로 구성
  * 비즈니스 : 비즈니스 동작(해결해야 할 문제)들의 모음
  * 도메인 : 문제들을 핵심 개념과 규칙으로 표현
  * 도메인 모델 : 이런 객체들 간의 관계까지 표현
    * 엔티티(Entity) : 테이블 모델로 존재 가능한 데이터 묶음
    * 어그리거트(Aggregate) : 데이터 변경 단위, 연관된 엔티티들의 묶음
    * 어그리거트 루트 : 어그리거트에서 도메인의 중심을 의미하는 엔티티 
  * 경계 컨텍스트(Bounded Context)
    * 각 도메인 모델들은 상호 배타적인 문제를 해결해야만 한다는 DDD 핵심원칙
  * 하위 도메인(Sub-Domain) 
    * Bounded-Context 원칙에 따라, Business Capability 를 높을 수 있는 방식으로 분리 해야한다
---
## 모놀리식에서 마이크로서비스으로 분해 Based on DDD, SRP - CCP
### 단계
1. <기능요건 : 전반적인 도메인> 기능 요건 정의하기 from 도메인 전문가
2. <도메인 모델 도출> 기능 요건으로 부터 사용자(액터) 시나리오 케이스 정의하고 도메인 모델 도출
3. <사용자 시나리오 정의> 2단계에서 도출한 시나리오를 만족하기 위해, 패캠 페이라는 시스템이 해야할 작업 식별하기
   * 전제 -> 조건 -> 결과
4. <시스템 작업 식별> 식별된 작업을 기준으로, "도메인" 즉 "서비스"를 정의하기. (비즈니스 능력별 기준)

### 분해과정에서의 장애물
* 네트워크 지연 : 서비스 간 통신 증가로 디버깅 포인트가 늘어남
* 트랜잭션 : Saga Pattern 을 이용하여 극복
* 가용성 : A 요청에 대해서, 해야하는 일이 얼마나 오랜 시간 운영이 가능한지 나타내는 정도
* 마이그레이션 과정 : 스트랭글러 패턴 (API Gateway-통합글루)를 이용하여 조금씩 전환 + Data Sync 맞추기

